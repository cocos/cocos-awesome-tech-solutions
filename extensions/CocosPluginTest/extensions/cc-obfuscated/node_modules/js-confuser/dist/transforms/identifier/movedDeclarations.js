"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _transform = _interopRequireDefault(require("../transform"));

var _traverse = require("../../traverse");

var _gen = require("../../util/gen");

var _insert = require("../../util/insert");

var _assert = require("assert");

var _order = require("../../order");

var _identifiers = require("../../util/identifiers");

var _scope = require("../../util/scope");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Defines all the names at the top of every lexical block.
 */
class MovedDeclarations extends _transform.default {
  constructor(o) {
    super(o, _order.ObfuscateOrder.MovedDeclarations);
  }

  match(object, parents) {
    return (0, _scope.isLexicalScope)(object);
  }

  transform(object, parents) {
    return () => {
      var body = (0, _traverse.isBlock)(object) ? object.body : object.consequent;
      (0, _assert.ok)(Array.isArray(body));
      var illegal = new Set();
      var defined = new Set();
      var variableDeclarations = Object.create(null);
      (0, _traverse.walk)(object, parents, (o, p) => {
        if (o.type == "Identifier") {
          if ((0, _scope.getLexicalScope)(o, p) !== object) {
            illegal.add(o.name);
          } else {
            var info = (0, _identifiers.getIdentifierInfo)(o, p);

            if (!info.spec.isReferenced) {
              return;
            }

            if (info.spec.isDefined) {
              if (info.isFunctionDeclaration || info.isClassDeclaration) {
                illegal.add(o.name);
              } else {
                if (defined.has(o.name)) {
                  illegal.add(o.name);
                } else {
                  defined.add(o.name);
                }
              }
            }
          }
        }

        if (o.type == "VariableDeclaration") {
          return () => {
            if (o.declarations.length === 1 && o.declarations[0].id.type === "Identifier") {
              var name = o.declarations[0].id.name; // Check if duplicate

              if (variableDeclarations[name] || o.kind !== "var") {
                illegal.add(name);
                return;
              } // Check if already at top


              if (body[0] === o) {
                illegal.add(name);
                return;
              }

              var replace = (0, _gen.AssignmentExpression)("=", (0, _gen.Identifier)(name), o.declarations[0].init || (0, _gen.Identifier)("undefined"));
              var forType = (0, _insert.isForInitialize)(o, p);

              if (forType === "left-hand") {
                replace = (0, _gen.Identifier)(name);
              } else if (!forType) {
                replace = (0, _gen.ExpressionStatement)(replace);
              }

              variableDeclarations[name] = {
                location: [o, p],
                replace: replace
              };
            }
          };
        }
      });
      illegal.forEach(name => {
        delete variableDeclarations[name];
      });
      var movingNames = Object.keys(variableDeclarations);

      if (movingNames.length === 0) {
        return;
      }

      var variableDeclaration = (0, _gen.VariableDeclaration)(movingNames.map(name => {
        return (0, _gen.VariableDeclarator)(name);
      }));

      if (object.type == "Program") {
        (0, _insert.prepend)(object, variableDeclaration);
      } else {
        body.unshift(variableDeclaration);
      }

      movingNames.forEach(name => {
        var {
          location,
          replace
        } = variableDeclarations[name];
        this.replace(location[0], replace);
      });
    };
  }

}

exports.default = MovedDeclarations;